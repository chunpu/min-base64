base64

btoa = binary to ASCII = encode

atob = ASCII to binary = decode

base64 使用 64 个 ASCII 字符

`[A-Za-z0-9+/] = 26 + 26 + 10 + 2 = 64`

`ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/`

注意这64位是按顺序的，就是说 0 = 00000000 = A, 63 = 11111111 = /

任何数据都能被 base64，因为 base64 接受的参数是 binary，任何数据都是 binary，比如 img, mp3, gzip 等

base64 最大的好处是二进制文件本来是完全不可读而且不可显示的，转成 base64 就成了文本

base64是可逆的，在只可以传递纯文本的时候，通过 base64 我们就可以传递一切了

base64 中还会出现 `=`，是用来补齐的

为什么用64位呢？我们知道64是2的6次方，一连串二进制被6位6位的等分

那为什么不是5位等分或者7位等分呢？

原因很简单，7位等分就需要128个字符，找不到这么多现成的字符，而5位等分只需要32个字符，连大小写字符都没用完，太浪费了

### base64 的补齐

base64 按6位分，而 byte 是8位二进制，最小公倍数是24

因此一个二进制转成二进制后，还要把位数补齐成24的倍数

### 一次加密事例

1. 源文件是字符串 `"abc"`
1. 先转成二进制 `[97, 98, 99]`
1. 对应的二进制就是 `[01100001, 01100010, 01100011]`，取法 `'a'.charCodeAt(0).toString(2)`
1. 正好24位不用补齐
1. 重新按6位分割成新的数组 `[011000, 010110, 001001, 100011]`
1. 对应十进制就是 `[24, 22, 9, 35]`
1. 映射到 base64 表中就是 `['Y', 'W', 'J', 'j']`，也就是 `YWJj`

但真的要把字符串拼出来然后再 split 吗？

我们必须用男人的方式来解决此问题，没错就是二进制！

1. 011000 = **011000**01, 右移两位就是, 也就是 `97 >> 2 = 24`
1. 010110 = 011000**01**, **0110**0010，`((97 & 0x03) << 4) | (98 >> 4) = 22`
1. 001001 = 0110**0010**, **01**100011，`((98 & 0x0f) << 2) | (99 >> 6) = 9`
1. 100011 = 01**100011**，`99 & 0x3f = 35`

